# МПР theory

## Уводна лекция -- Клиент-сървър

```def``` РИС - ***разпределителна изчислителна система*** - набор от съединени канали, свързващи независими компютри, за които от потребителска гледна точка програмното осигуряване изглежда като единно цяло. 

* автономност на възлите
* представяне на системата за потребителя като единна структура

***Основното свързващо звено на РИС е програмното осигуряване.(ПО)***

```def``` Парадигмата клиент-сървър\:  **един или няколко клиенти** и **един или няколко сървъра** съвместно с **базова операционна система** и **среда за взаимодействие** образуват **единна система**, осигуряваща **разпределени изчисления**, **анализ** и **представяне на данните** 

## Клиент-сървър в HTTP
HTTP Client(Browser) <-> HTTP Server(hostname: port)
over TCP/IP

Request -> Response

Уеб сървърите ибокновено осигуряват два механизма за взаимодействие\:

* ```CGI``` -- common gateway interface

* ```APIs``` -- програмен интерфейс на приложенията на сървъра

## UDP сокети
User Datagram Protocol
***Сравнение м/у TCP и UDP предаване на данни***

* **при TCP**: с **непрекъснат поток** от данни TCP осигурява механизъм за предаване, позволяващ прехвърлянето на **произволен брой байтове**; преди да започне да предава данни с отдалечената машина, обменя с нея служебна информация(***3 way handshake?***)

* **при UDP** -- преди да предава данни UDP не установява логическо съединение; информацията се предава, като се предполага, че приемащата страна я очаква

Не обединява няколко съобщения в едно цяло и не дели едно съобщение на части.


### Сокети в UNIX

възникват различни проблеми, например при предаването на иноформация като числа, затова има реализирани функции във библиотеките <netinet/in.h> и т.н.

Сокетите в C UNIX се създават чрез ```socket```


```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

```domain``` определя семейството протоколи
* ```PF_INET``` - за TCP/IP семейството
протоколи;
* ```PF_UNIX``` - за семейството вътрешни
протоколи на UNIX, още наричано UNIX
domain.

```type``` определя семантиката на обмена на информацията  

* SOCK_STREAM -- потоково предаване
* SOCK_DGRAM -- пакетно предаване, в TCP / IP протоколния стек съществува само един протокол за дейтаграмни сокети -- **UDP**.

```sendto, recvfrom``` over UDP

За преобразуване на домейн-името в IP адрес се използва функцията **gethostbyname**

За gethostbyaddr host-ът се задава в binary.

### Example
Here client and server are equivalent.  

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <arpa/inet.h> 
#include <netinet/in.h> 

#define PORT    8080 
#define MAXLINE 1024 

int main(int argc, char *argv[]) { 
    int sockfd, n; 
    char buffer[MAXLINE]; 
    char *hello = "Hello from client"; 
    struct sockaddr_in servaddr, cliaddr; 
  
    // Creating socket file descriptor 
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { 
        perror("socket creation failed"); 
        exit(EXIT_FAILURE); 
    } 
  
    memset(&servaddr, 0, sizeof(servaddr)); 
    memset(&cliaddr, 0, sizeof(cliaddr)); 
      
    // Filling server information 
    servaddr.sin_family    = AF_INET; // IPv4 
    servaddr.sin_addr.s_addr = INADDR_ANY; 
    servaddr.sin_port = htons(PORT); 
  
    // Bind the socket with the server address 
    if ( bind(sockfd, (const struct sockaddr*)&servaddr,  
            sizeof(servaddr)) < 0 ) 
    { 
        perror("bind failed"); 
        exit(EXIT_FAILURE); 
    } 
  
    int len, n; 
    n = recvfrom(sockfd, (char*)buffer, MAXLINE,  
                 MSG_WAITALL, (struct sockaddr*)&cliaddr, 
                 &len); 
    buffer[n] = '\0'; 
    printf("Client : %s\n", buffer); 
  
    sendto(sockfd, (const char *)hello, strlen(hello),  
        MSG_CONFIRM, (const struct sockaddr *) &cliaddr, 
            len); 
    printf("Hello message sent.\n"); 
  
    return 0; 
}

```

## TCP сокети

Когато изпращаме данни по TCP, клиента и сървъва имат следните действия\:  

* ***Сървър***
Създава си сокет -> ```socket()```  

Именова се сокета, тоест се заземява за даден адрес(IP адрес, port) -> ```bind()```  
Слуша на адреса, тоест се вика ```listen()``` и сокета преминава в пасивно слушащо състояние, тоест ще се използва за приемане на заявки за връзки от клиенти чрез ```accept()```, като така се създава нов сокет(и се връща неговия файлов декриптор), който се използва като комуникационен канал между клиента и сървъра.    

Когато е приета връзка чрез ```accept()```, клиента бива обслужен, т.е. след цикъл write и read извиквания от клиента и сървъра, сокета може да бъде затворен чрез ```close()```(и при клиента така, после може да затворим сокета след завършване на комуникацията със сървъра)


* ***Клиент***  
Изпраща заявка за установяване на логическо съединение към даден адрес(IP адрес, порт), т.е. към сървъра.

TCP е надежден дуплексен протокол. За целта се използва\:  
* номериране на предваните пакети
* контрол на реда на получаването им
* потвърждения за получаването на пакета
* повторно изпращане при отсъствие на потвърждение
* изчисляване на check-суми за предаваната информация

## Winsock API
В MSWindows е необходимо библиотеката Winsock явно да се инициализира преди да се използват функциите й. Това се прави с функцията WSAStartup. Преси излизането от програмата е необходимо да се извика WSACleanup за деинициализация на Winsock библиотеката и освобождаване на използваните от това приложение ресурси;  

При MSWindows сокетите\: вместо write -> send
                         вместо read -> recv
                         вместо close -> closesocket

Също, в сравнение с Unix, няма **fork** извикване
Също socket файловия дескриптор не е както в UNIX цяло число, ами има отделно дефиниран тип SOCKET.

errno -> WSAGetLastError


## Сокети в Java

В Java класовете Socket и SeverSocket представляват клиентски сокет и сървър сокет, като работата се опростява с това, че при конструкторите, при подаването на параметри, при сървъра директно да се осъществява bind, при клиента директно при конструирането да се осъществява connect. Нали говорим за TCP сокети, където се осъществява логическо съединение. Също и писането и четенето са доста улеснени, стават съответно с PrintWritter и BufferedReader. За UDP сокетите, ползват се класовете DatagramPacket за създаване и получаване на пакети и DatagramSocket, тук методите за писане и четене са send и receive.

Основните методи, използвани за инициализация на
обектите InetAddress, са:
* ```public static InetAddress getLocalHost()```: Връща обекта InetAddress, който
съдържа IP адреса на локалния компютър.
* ```public static InetAddress getByName(String host)```: Връща обекта
InetAddress, който съдържа IP адреса, съответстващ на името на хоста,
предадено на метода като String.
* ```public static InetAddress[] getAllByName(String host)```: Връща масив от
обекти InetAddress, който съдържа IP адресите, съответстващи на
името на хоста, предадени на метода като String


## RPC

Stands for **R**emote **P**rocedure **C**all

Вместо директна работа със сокети, програмистът работи така, както с локална процедура.

* асиметричност -- едната от взаимодействащите страни е инициатор;

* синхронност -- изпълнението на извикващата процедура спира от момента на изпращане на заявката и се възобновява едва след като извикваща процедура върне 

***Недостатъци:***
* Ниска защитеност, ниска сигурност, ниска надеждност, ниска съвемстимост при различните езици за програмиране

## RMI

Stands for **R**emote **M**ethod **I**nvocation -- отдалечено извикване на методи  

Представлява механизъм(API), ползволяващ на обект от една Java машина да извика методи на друга Java машина. RMI работи в мрежа. RMI е относително лесна за използване, разкрива нова парадигма на разпределените обектни изчисления.

## SGML, HTML, XML

**M**arkup **L**anguages

* SGML

Stands for **S**tructured **G**eneralized **M**arkup **L**anguage 
Той е родоначалник на всички хипертекстови езици.

* XML е опростено подможество на SGML
* HTML първоначално е бил едно от SGML приложенията

Такива документи са структурирани като коренови дървета.

* HTML 
Две основни характеристики\: **хипертекст**, т.е. документът съдържа хипервръзки към други документи; **универсалност**, т.е. всеки HTML документ може да бъде разгледан във всеки уеб браузър в Интернет. Набор от SGML правила, формулирани във вид за определяне на типа на документа (DTD, т.е. Document Type Definition), обясняващи какво точно обозначават таговете и елементите

* XML е текстов формат, предназначен за\:
    * съхранение на структурирани данни
    * обмен на информация между програми
    * създаване специализиращи markup езици на негова основа

XML има строго определен синтаксис, не позволява не затваряне на тагове.

## JavaScript
JS е прототипно-ориентиран скриптов език за програмиране, диалект е на ECMAScript. Обектно-ориентиран е, но наследяването става чрез механизма на прототипите. Слабо типизиран. Интерпретира се, най-често в браузъра.
Кодът се интерпретира в браузъра от страната на клиента.

Цели интерактивност на уеб-страниците.

Изполва се за създаване на динамични и интерактивни ефекти за уеб страници. Може да се манипулират HTML елементи, да се създават анимации и да се обновява съдържанието на уеб-страницата динамично и т.н. Може да вграждаме HTML код директно в HTML документ или да е в отделен файл и със скрипт таг да бъде вграден.


## CGI

Stands **C**ommon **G**ateway **I**nterface  
* едно от най-разпространените средства за създаване на динамични уеб-страници

* не е отделен език, а множество от спецификации, които позволяват на уеб-съвъра да комуникира с други приложения и програми.

* стандарт, който определя начина, по който уеб сървърите могат да използват външни програми

* CGI програмите се изпълняват в реално времем което дава възможност за генериране на динамично съдържание


* заявката към URL адрес на дадена CGI програма се формира след като потребителят избере хипервръзка или подаде формуляр, като за да направи заявка браузърът използва HTTP


## ISAPI

Internet Server API

ISAPI приложенията се използват вместо CGI, ако уеб сървърът е създаден на базата на Microsoft Internet Information Server, по-тясно интегрирани са и допринасят за бързодействието. 
Те представляват dynamically linked libraries, които директно си взаимодействат с Internet Information service API, зареждат се и няма нужда да се прави нов процес за обработка на всяка HTTP заявка.

Microsoft Application Server Pages(ASP) и .NET Framework-а са базирани са построени като приложения на Internet Server API-то.

## Java Servlet

Представлява Java клас, който се използва като разширение на възможностите на въвъри, предоставящи базирани на заявка-отговор порграмен модел услуги. Един сървлет е една сървърна програма, която обслужва HTTP заявки и връща като резултат HTTP отговори. От тази гледна точка прилича на CGI.

Също не прави по процес за всяка HTTP заявка, а изполва нишки, което пести ресурси. Platform-independent е, бързо, гъвкаво и достъпно.

Заявки от тип GET и POST.


## ASP.NET
Stands for Active Sever Pages 

Tехнология за създаване на уеб приложения и уеб услуги на Microsoft, позволява динамично създаване на уеб страници на сървърната страна. Работи на операционните системи MSWindows NT и на уеб сървър Microsoft IIS.

Приложения за  ASP.NET могат да се пишат на всички езици за програмиране, които се компилират до Common Intermediate Language(CIL).

Основният компонент на ASP.NET е уеб формата -- уеб страницата, която потребителят вижда в браузъра си под формата на HTML.

Всяко ASP.NET приложение се изгражда от една или повече уеб форми, които могар да взаимодействат помежду си, като по този начин правят приложението интерактивно.



## PHP

Mention the recursive acronym: PHP: Hypertext Processor.

PHP е скрипт-машина, която комбинира множество готови уеб-инструменти и интерпретатор на форми за генериране на бърз, лесен и с отворен код език за писане на скриптове от страна на сървъра. Подходящ е за по-малки проекти. Не е толкова надежден колкото ASP.NET, но е по-бърз и безплатен.


## JSP
Stands for Java Server Pages

Позволява лесно създаване на уеб страници със статично и динамично съдържание. JSP страниците предоставят такива възможности, каквито не могат да бъдат изпълнени от сървлетите. JSP документите автоматично се превеждат до сървлети.

## CORBA на Object Management Group

Stands for Common Object Request Broker Architecture(обща архитектура на брокер за обектни заявки) 

Целта на CORBA, Java EE и Microsoft .NET е\:
* интеграция на услугите за приложенията на базата на различни платформи  

*  осигуряване на взаимодействие\: прозрачен механизъм за общуване и обмен на данни между елементите на разпределителните изчислителни системи

Стандартът CORBA е първата разработена архитектура за корпоративни системи и Интернет приложения.  


## Java Enterprise Edition

Най-развитите платдформи за разпределени приложения са Microsoft .NET и Java EE. Java EE е platform-independent, т.е. не зависи от апаратната платформа и от операционната среда.

Представлява първият стандарт за създаване на корпоративни раздпределени многоелементни приложения. Приела е всички основни стандарти на CORBA и XML.

Всички компоненти на JEE имат едно общо свойство\: трябва да са написани на Java.

Основен елемент на Java EE е компонентният модел **Enterprise JavaBeans** -- сървърен компонент, съдържащ бизнес логиката на приложението.



## Microsoft .NET Framework

Не е платформено независима, въпреки че има и такива реализации. Направена е за Windows OS. В рамките на .NET има аналози на основните видове компоненти на Jave Enterprise Edition.

На уеб компонентите съответстват компонентите, построени по технологията ASP.NET, а на EJВ(Enterprise JavaBeans), свързващи приложението със СУБД -- компонентите ADO.NET.

## Service-Oriented Architecture

SOA не е технология, а философия, концепция, парадигма, подход за построяване на корпоративни информационни системи, интеграция на бизнеса и на информационните технологии. По своята същност SOA не съдържа нови революционни идеи, а представлява обобщение на най-добрите практики за създаване на програмно-информационни системи. 

За целите на бизнеса основните изисквания към компютърните мрежи са безопаснотта и скоростта на предаване на информацията, което се реализира на нивото на транспортните протоколи. 

Като погледът е бил насочен към базовите уеб технолофии или това, което е основата на Интернет, именно\:

* TCP/IP

* HTML

* XML

## GRID технологии

Грид е система, която координира разпределени ресурси посредством стандартни, отворени, универсални протоколи и интерфейси за осигуряване на нетривиално качество на обслужване(QoS -- Quality of Service).

Основната идея, заложена зад грид изчисленията, представлява централизирано отдалечено предоставяне на ресурси, необходими за решаването на разнородни изчислителни задачи. В някакъв смисъл можем да направим аналогия с електрическата мрежа -- нас не ни унтересува откъде идва електричеството в контакта, но въпреки това можем да използваме този ресурс за нуждите си. Това директно се транслира в идеологията на грид\: ние можем да зададем всякаква задача за решаване на всеки комютър или мобилно устройство, като ресурсите за това изчисление трябва автоматично да се предоставят от отдалечени високо-производителни сървъри. независимо от типа на нашата задача.


* Слоеве в архитектурата на грид\:

1. Базов слой(Fabric) -- съдържа различни ресурси, като компютри, устройства за съхраняване, мрежи, сензори и др.  

2. Свързващ слой(Connectivity) -- определя комуникационните протоколи и протоколите за автентикация

3. Ресурсен слой(Resourse) -- реализира проколите за взаимодействие с ресурсите на разпределителните изчислителни системи и тяхното управление

4. Колетивен слой(Collective) -- управления на каталозите с ресурсите, диагностика, мониторинг  

5. Приложен слой(Applications) -- инструментариум за работа с грид и потребителските приложения



## Облачни изчисления

Няма съвсем ясно определение за това какво са облачни изчисления.

## Архитектури на информационните системи


