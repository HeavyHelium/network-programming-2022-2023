# МПР theory

## Уводна лекция -- Клиент-сървър

```def``` РИС - ***разпределителна изчислителна система*** - набор от съединени канали, свързващи независими компютри, за които от потребителска гледна точка програмното осигуряване изглежда като единно цяло. 

* автономност на възлите
* представяне на системата за потребителя като единна структура

***Основното свързващо звено на РИС е програмното осигуряване.(ПО)***

```def``` Парадигмата клиент-сървър\:  **един или няколко клиенти** и **един или няколко сървъра** съвместно с **базова операционна система** и **среда за взаимодействие** образуват **единна система**, осигуряваща **разпределени изчисления**, **анализ** и **представяне на данните** 

## Клиент-сървър в HTTP
HTTP Client(Browser) <-> HTTP Server(hostname: port)
over TCP/IP

Request -> Response

Уеб сървърите ибокновено осигуряват два механизма за взаимодействие\:

* ```CGI``` -- common gateway interface

* ```APIs``` -- програмен интерфейс на приложенията на сървъра

## UDP сокети
User Datagram Protocol
***Сравнение м/у TCP и UDP предаване на данни***

* **при TCP**: с **непрекъснат поток** от данни TCP осигурява механизъм за предаване, позволяващ прехвърлянето на **произволен брой байтове**; преди да започне да предава данни с отдалечената машина, обменя с нея служебна информация(***3 way handshake?***)

* **при UDP** -- преди да предава данни UDP не установява логическо съединение; информацията се предава, като се предполага, че приемащата страна я очаква

Не обединява няколко съобщения в едно цяло и не дели едно съобщение на части.


### Сокети в UNIX

възникват различни проблеми, например при предаването на иноформация като числа, затова има реализирани функции във библиотеките <netinet/in.h> и т.н.

Сокетите в C UNIX се създават чрез ```socket```


```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

```domain``` определя семейството протоколи
* ```PF_INET``` - за TCP/IP семейството
протоколи;
* ```PF_UNIX``` - за семейството вътрешни
протоколи на UNIX, още наричано UNIX
domain.

```type``` определя семантиката на обмена на информацията  

* SOCK_STREAM -- потоково предаване
* SOCK_DGRAM -- пакетно предаване, в TCP / IP протоколния стек съществува само един протокол за дейтаграмни сокети -- **UDP**.

```sendto, recvfrom``` over UDP

За преобразуване на домейн-името в IP адрес се използва функцията **gethostbyname**

За gethostbyaddr host-ът се задава в binary.

### Example
Here client and server are equivalent.  

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <arpa/inet.h> 
#include <netinet/in.h> 

#define PORT    8080 
#define MAXLINE 1024 

int main(int argc, char *argv[]) { 
    int sockfd, n; 
    char buffer[MAXLINE]; 
    char *hello = "Hello from client"; 
    struct sockaddr_in servaddr, cliaddr; 
  
    // Creating socket file descriptor 
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) { 
        perror("socket creation failed"); 
        exit(EXIT_FAILURE); 
    } 
  
    memset(&servaddr, 0, sizeof(servaddr)); 
    memset(&cliaddr, 0, sizeof(cliaddr)); 
      
    // Filling server information 
    servaddr.sin_family    = AF_INET; // IPv4 
    servaddr.sin_addr.s_addr = INADDR_ANY; 
    servaddr.sin_port = htons(PORT); 
  
    // Bind the socket with the server address 
    if ( bind(sockfd, (const struct sockaddr*)&servaddr,  
            sizeof(servaddr)) < 0 ) 
    { 
        perror("bind failed"); 
        exit(EXIT_FAILURE); 
    } 
  
    int len, n; 
    n = recvfrom(sockfd, (char*)buffer, MAXLINE,  
                 MSG_WAITALL, (struct sockaddr*)&cliaddr, 
                 &len); 
    buffer[n] = '\0'; 
    printf("Client : %s\n", buffer); 
  
    sendto(sockfd, (const char *)hello, strlen(hello),  
        MSG_CONFIRM, (const struct sockaddr *) &cliaddr, 
            len); 
    printf("Hello message sent.\n"); 
  
    return 0; 
}

```

## TCP сокети

Когато изпращаме данни по TCP, клиента и сървъва имат следните действия\:  

* ***Сървър***
Създава си сокет -> ```socket()```  

Именова се сокета, тоест се заземява за даден адрес(IP адрес, port) -> ```bind()```  
Слуша на адреса, тоест се вика ```listen()``` и сокета преминава в пасивно слушащо състояние, тоест ще се използва за приемане на заявки за връзки от клиенти чрез ```accept()```, като така се създава нов сокет(и се връща неговия файлов декриптор), който се използва като комуникационен канал между клиента и сървъра.    

Когато е приета връзка чрез ```accept()```, клиента бива обслужен, т.е. след цикъл write и read извиквания от клиента и сървъра, сокета може да бъде затворен чрез ```close()```(и при клиента така, после може да затворим сокета след завършване на комуникацията със сървъра)


* ***Клиент***  
Изпраща заявка за установяване на логическо съединение към даден адрес(IP адрес, порт), т.е. към сървъра.

TCP е надежден дуплексен протокол. За целта се използва\:  
* номериране на предваните пакети
* контрол на реда на получаването им
* потвърждения за получаването на пакета
* повторно изпращане при отсъствие на потвърждение
* изчисляване на check-суми за предаваната информация

## Winsock API
В MSWindows е необходимо библиотеката Winsock явно да се инициализира преди да се използват функциите й. Това се прави с функцията WSAStartup. Преси излизането от програмата е необходимо да се извика WSACleanup за деинициализация на Winsock библиотеката и освобождаване на използваните от това приложение ресурси;  

При MSWindows сокетите\: вместо write -> send
                         вместо read -> recv
                         вместо close -> closesocket

Също, в сравнение с Unix, няма **fork** извикване
Също socket файловия дескриптор не е както в UNIX цяло число, ами има отделно дефиниран тип SOCKET.

errno -> WSAGetLastError


## Сокети в Java

В Java класовете Socket и SeverSocket представляват клиентски сокет и сървър сокет, като работата се опростява с това, че при конструкторите, при подаването на параметри, при сървъра директно да се осъществява bind, при клиента директно при конструирането да се осъществява connect. Нали говорим за TCP сокети, където се осъществява логическо съединение. Също и писането и четенето са доста улеснени, стават съответно с PrintWritter и BufferedReader. За UDP сокетите, ползват се класовете DatagramPacket за създаване и получаване на пакети и DatagramSocket, тук методите за писане и четене са send и receive.

Основните методи, използвани за инициализация на
обектите InetAddress, са:
* ```public static InetAddress getLocalHost()```: Връща обекта InetAddress, който
съдържа IP адреса на локалния компютър.
* ```public static InetAddress getByName(String host)```: Връща обекта
InetAddress, който съдържа IP адреса, съответстващ на името на хоста,
предадено на метода като String.
* ```public static InetAddress[] getAllByName(String host)```: Връща масив от
обекти InetAddress, който съдържа IP адресите, съответстващи на
името на хоста, предадени на метода като String


## RPC

Stands for **R**emote **P**rocedure **C**all

Вместо директна работа със сокети, програмистът работи така, както с локална процедура.

* асиметричност -- едната от взаимодействащите страни е инициатор;

* синхронност -- изпълнението на извикващата процедура спира от момента на изпращане на заявката и се възобновява едва след като извикваща процедура върне 

***Недостатъци:***
* Ниска защитеност, ниска сигурност, ниска надеждност, ниска съвемстимост при различните езици за програмиране

## RMI

Stands for **R**emote **M**ethod **I**nvocation -- отдалечено извикване на методи  

Представлява механизъм(API), ползволяващ на обект от една Java машина да извика методи на друга Java машина. RMI работи в мрежа. RMI е относително лесна за използване, разкрива нова парадигма на разпределените обектни изчисления.

## SGML, HTML, XML

**M**arkup **L**anguages

* SGML

Stands for **S**tructured **G**eneralized **M**arkup **L**anguage 
Той е родоначалник на всички хипертекстови езици.

* XML е опростено подможество на SGML
* HTML първоначално е бил едно от SGML приложенията

Такива документи са структурирани като коренови дървета.

* HTML 
Две основни характеристики\: **хипертекст**, т.е. документът съдържа хипервръзки към други документи; **универсалност**, т.е. всеки HTML документ може да бъде разгледан във всеки уеб браузър в Интернет. Набор от SGML правила, формулирани във вид за определяне на типа на документа (DTD, т.е. Document Type Definition), обясняващи какво точно обозначават таговете и елементите

* XML е текстов формат, предназначен за\:
    * съхранение на структурирани данни
    * обмен на информация между програми
    * създаване специализиращи markup езици на негова основа

XML има строго определен синтаксис, не позволява не затваряне на тагове.

## JavaScript
JS е прототипно-ориентиран скриптов език за програмиране, диалект е на ECMAScript. Обектно-ориентиран е, но наследяването става чрез механизма на прототипите. Слабо типизиран. Интерпретира се, най-често в браузъра.
Кодът се интерпретира в браузъра от страната на клиента.

Цели интерактивност на уеб-страниците.

Изполва се за създаване на динамични и интерактивни ефекти за уеб страници. Може да се манипулират HTML елементи, да се създават анимации и да се обновява съдържанието на уеб-страницата динамично и т.н. Може да вграждаме HTML код директно в HTML документ или да е в отделен файл и със скрипт таг да бъде вграден.


## CGI

Stands Common Gateway Interface

## ISAPI

Internet Server API

## Java Servlet

## ASP.NET
Stands for Active Sever Pages 

## PHP


## JSP
Stands for Java Server Pages

## Java Enterprise Edition

## Microsoft .NET Framework

## Service-Oriented Architecture

## Архитектури на информационните системи


